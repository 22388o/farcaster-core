//! Arbitrating transaction module

use std::fmt::Debug;

use crate::blockchain::{Fee, FeeStrategy};
use crate::role::Arbitrating;

/// Base trait for arbitrating transactions. Defines methods to create the wrappers from a partial
/// arbitrating transaction and into partial arbitrating transaction.
pub trait Transaction<Ar>: Debug
where
    Ar: Arbitrating,
    Self: Sized,
{
    /// Used to extract the transaction in the defined partial format on the arbitrating
    /// blockchain. The partial format is used to exchange unsigned transactions.
    fn to_partial(&self) -> Option<Ar::PartialTransaction>;

    /// Used to generate the wrapper transaction structure from the defined format on the
    /// arbitrating blockchain.
    fn from_partial(tx: &Ar::PartialTransaction) -> Option<Self>;
}

/// Must be implemented on transactions with failable opperations.
pub trait Failable {
    /// Errors returned by the failable methods.
    type Err;
}

/// Define a transaction broadcastable by the system. Externally managed transaction are not
/// broadcastable.
pub trait Broadcastable<Ar>
where
    Ar: Arbitrating,
    Self: Sized,
{
    /// Finalizes the transaction and return a fully signed transaction type as defined in the
    /// arbitrating blockchain. Used before broadcasting the transaction on-chain.
    ///
    /// The argumets `T` is used to inject the keys material needed to finalize the transaction.
    fn finalize<T>(&self, args: T) -> Ar::Transaction;
}

/// Implemented by transactions that can be link to form chains of logic.
pub trait Linkable<Ar>: Failable
where
    Ar: Arbitrating,
    Self: Sized,
{
    /// Returned type of the consumable funding output, used to chain other transactions.
    type Output;

    /// Return the consumable output of this transaction. The output does not contain the witness
    /// data allowing spending the output, only the data that points to the consumable output.
    fn get_consumable_output(&self) -> Result<Self::Output, Self::Err>;
}

pub trait Spendable<Ar>: Linkable<Ar> + Failable
where
    Ar: Arbitrating,
    Self: Sized,
{
    /// Type returned by methods generating witnesses, used to unlock assets.
    type Witness;

    /// Generate the witness to unlock the default path of the asset lock.
    fn generate_witness(&self) -> Result<Self::Witness, Self::Err>;
}

/// Defines a transaction where the consumable output has two paths: a successful path and a
/// failure path.
pub trait Forkable<Ar>: Spendable<Ar> + Failable
where
    Ar: Arbitrating,
    Self: Sized,
{
    /// Generates the witness used to unlock the second path of the asset lock. The failure path.
    fn generate_failure_witness<T>(&self, args: T) -> Result<Self::Witness, Self::Err>;
}

/// Funding is NOT a transaction generated by this library but the address is, we need to spend the
/// funding from the `lock (b)` transaction latter.
pub trait Funding<Ar>: Spendable<Ar> + Failable
where
    Ar: Arbitrating,
    Self: Sized,
{
    /// Create a new funding 'output', or equivalent depending on the blockchain and the
    /// cryptographic engine, with the help of a generic argument of type `T`.
    fn initialize(privkey: Ar::PrivateKey) -> Result<Self, Self::Err>;

    /// Return the address to use for the funding.
    fn get_address(&self) -> Result<Ar::Address, Self::Err>;

    /// Update the transaction, this is used to update the data when the funding transaction is
    /// seen on-chain.
    ///
    /// This function is needed because we assume that the transaction is created outside of the
    /// system by an external wallet, the txid is not known in advance.
    fn update(&mut self, args: Ar::Transaction) -> Result<(), Self::Err>;
}

/// The `lock (b)` transaction consumes the `funding (a)` transaction and creates the scripts used
/// by `buy (c)` and `cancel (d)` transactions.
pub trait Lock<Ar>: Transaction<Ar> + Broadcastable<Ar> + Forkable<Ar> + Failable
where
    Ar: Arbitrating,
    Self: Sized,
{
    /// Creates a new `lock (b)` transaction based on the `funding (a)` transaction and the public
    /// keys for the roles, return a new `lock (b)` transaction.
    fn initialize(
        prev: &impl Funding<Ar>,
        timelock: Ar::Timelock,
        fee_strategy: &impl FeeStrategy,
        pubkeys: (Ar::PublicKey, Ar::PublicKey),
    ) -> Result<Self, Self::Err>;
}

pub trait Buy<Ar>: Transaction<Ar> + Broadcastable<Ar> + Spendable<Ar> + Failable
where
    Ar: Arbitrating,
    Self: Sized,
{
    fn initialize<T>(
        prev: &impl Lock<Ar>,
        fee_strategy: &impl FeeStrategy,
        args: T,
    ) -> Result<Self, Self::Err>;
}

pub trait Cancel<Ar>: Transaction<Ar> + Broadcastable<Ar> + Forkable<Ar> + Failable
where
    Ar: Arbitrating,
    Self: Sized,
{
    fn initialize<T>(
        prev: &impl Lock<Ar>,
        timelock: Ar::Timelock,
        fee_strategy: &impl FeeStrategy,
        args: T,
    ) -> Result<Self, Self::Err>;
}

pub trait Refund<Ar>: Transaction<Ar> + Broadcastable<Ar> + Spendable<Ar> + Failable
where
    Ar: Arbitrating,
    Self: Sized,
{
    fn initialize<T>(
        prev: &impl Cancel<Ar>,
        fee_strategy: &impl FeeStrategy,
        args: T,
    ) -> Result<Self, Self::Err>;
}

pub trait Punish<Ar>: Transaction<Ar> + Broadcastable<Ar> + Spendable<Ar> + Failable
where
    Ar: Arbitrating,
    Self: Sized,
{
    fn initialize<T>(
        prev: &impl Cancel<Ar>,
        fee_strategy: &impl FeeStrategy,
        args: T,
    ) -> Result<Self, Self::Err>;
}
